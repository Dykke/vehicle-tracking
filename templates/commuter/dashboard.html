{% extends "base.html" %}

{% block title %}Live Map - TransportWatch{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
<style>
    .map-container {
        position: relative;
        height: calc(100vh - 150px);
        margin-top: 16px;
    }
    
    #map {
        height: 100%;
        width: 100%;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .vehicle-list {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 300px;
        max-height: calc(100% - 40px);
        overflow-y: auto;
        background-color: var(--background-color);
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        z-index: 1000;
    }
    
    .vehicle-item {
        padding: 16px;
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        transition: background-color 0.2s;
    }
    
    .vehicle-item:hover {
        background-color: var(--hover-color);
    }
    
    .vehicle-item:last-child {
        border-bottom: none;
    }

    .no-vehicles {
        padding: 16px;
        text-align: center;
        color: var(--text-secondary);
    }
    
    .page-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 16px;
        width: 100%;
    }
    
    .page-header h1 {
        margin: 0;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 1.5rem;
    }
    
    /* Mobile responsive styles */
    @media (max-width: 768px) {
        .map-container {
            height: calc(100vh - 120px);
            margin-top: 12px;
        }
        
        .vehicle-list {
            width: 250px;
        }
        
        .vehicle-item {
            padding: 12px;
        }
        
        .page-header h1 {
            font-size: 1.3rem;
        }
    }
    
    @media (max-width: 480px) {
        .map-container {
            height: calc(100vh - 100px);
            margin-top: 8px;
        }
        
        .vehicle-list {
            width: 200px;
            top: 10px;
            right: 10px;
            max-height: calc(100% - 20px);
        }
        
        .vehicle-item {
            padding: 8px;
            font-size: 0.9rem;
        }
        
        .page-header {
            gap: 8px;
            margin-bottom: 8px;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .page-header h1 {
            font-size: 1.2rem;
            margin-bottom: 8px;
        }
        
        .page-header > div {
            width: 100%;
            display: flex;
            justify-content: flex-start;
        }
    }
    
    .floating-center-btn {
        position: absolute;
        bottom: 20px;
        left: 20px;
        z-index: 1000;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        font-size: 1.2rem;
    }
    
    .floating-center-btn:hover {
        background-color: #0056b3;
    }
    
    .floating-center-btn:active {
        transform: translateY(1px);
    }
</style>
{% endblock %}

{% block content %}
<div class="page-header">
    <h1><i class="fas fa-map-marked-alt"></i> <span>Live Vehicle Tracking</span></h1>
    
</div>

<div class="map-container">
    <div id="map"></div>
    <button id="floatingCenterMap" class="floating-center-btn">
        <i class="fas fa-location-crosshairs"></i>
    </button>
    <div class="vehicle-list card">
        <div style="padding: 12px; border-bottom: 1px solid var(--border-color);">
            <h3><i class="fas fa-list"></i> Active Vehicles</h3>
        </div>
        <div id="vehicleList">
            <div class="no-vehicles">
                <i class="fas fa-info-circle"></i>
                No active vehicles at the moment
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script>
let map;
let markers = {};
let userMarker;
let userLocation;
let routePolylines = {};

// Continuous location tracking for commuters
let watchPositionId = null;
let lastReportedPosition = null;
const MIN_DISTANCE_CHANGE = 10; // meters
const MIN_TIME_INTERVAL = 10000; // 10 seconds

// Auto-follow feature
let autoFollowEnabled = false;

// Initialize map
function initMap() {
    map = L.map('map').setView([0, 0], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
    }).addTo(map);
    
    // Get user's location
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                
                // Validate coordinates
                if (isValidCoordinate(lat, lng)) {
                    userLocation = [lat, lng];
                    map.setView(userLocation, 13);
                    
                    // Add user marker
                    const userIcon = L.divIcon({
                        html: '<i class="fas fa-user" style="color: var(--primary-color); font-size: 24px;"></i>',
                        className: 'user-marker',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });
                    
                    userMarker = L.marker(userLocation, {icon: userIcon})
                        .addTo(map)
                        .bindPopup('Your Location');
                        
                    // Update user location periodically
                    startLocationTracking();
                } else {
                    console.error('Invalid coordinates received from geolocation API');
                    setDefaultMapView();
                }
            },
            (error) => {
                console.error('Error getting location:', error);
                setDefaultMapView();
            },
            { 
                enableHighAccuracy: true, 
                timeout: 10000, 
                maximumAge: 5000 
            }
        );
    } else {
        console.error('Geolocation is not supported by this browser');
        setDefaultMapView();
    }
}

// Set default map view when geolocation fails
function setDefaultMapView() {
    // Default to a central location if geolocation fails
    map.setView([0, 0], 2);
    document.getElementById('centerMap').disabled = true;
}

// Start tracking user location
function startLocationTracking() {
    // Start continuous tracking instead of the old tracking method
    if (document.getElementById('tracking-toggle')) {
        document.getElementById('tracking-toggle').checked = true;
        startContinuousLocationTracking();
    }
}

// Validate coordinates
function isValidCoordinate(lat, lng) {
    return lat && lng && !isNaN(lat) && !isNaN(lng) && 
           lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
}

// Update vehicles on map
function fetchVehicles() {
    fetch('/api/vehicles/active')
        .then(response => response.json())
        .then(data => {
            const vehicles = data.vehicles || [];
            console.log('Fetched vehicles:', vehicles); // Debug the response
            updateMap(vehicles);
            updateList(vehicles);
        })
        .catch(error => console.error('Error fetching vehicles:', error));
}

function updateMap(vehicles) {
            const vehicleList = document.getElementById('vehicleList');
            
    // Clear old vehicle list
    vehicleList.innerHTML = '';
    
    if (vehicles.length === 0) {
                vehicleList.innerHTML = `
                    <div class="no-vehicles">
                        <i class="fas fa-info-circle"></i>
                        No active vehicles at the moment
                    </div>
                `;
            }
            
    console.log('Updating vehicles on map:', vehicles.length);
            
    vehicles.forEach(vehicle => {
        // Debug each vehicle's coordinates
        console.log(`Vehicle #${vehicle.id}:`, {
            latitude: vehicle.latitude,
            longitude: vehicle.longitude,
            current_latitude: vehicle.current_latitude, 
            current_longitude: vehicle.current_longitude
        });

        // Use either latitude/longitude or current_latitude/current_longitude
        const lat = vehicle.latitude || vehicle.current_latitude;
        const lng = vehicle.longitude || vehicle.current_longitude;
        
        // Skip if no coordinates
        if (!lat || !lng) {
            console.log(`Skipping vehicle #${vehicle.id} - missing coordinates`);
                    return;
                }
        
        // Get a displayed name for the vehicle
        const vehicleName = vehicle.registration_number || vehicle.vehicle_number || `Vehicle #${vehicle.id}`;
        
        const position = [lat, lng];
        console.log(`Adding vehicle ${vehicleName} at position:`, position);
                
                // Update or create marker
                if (markers[vehicle.id]) {
                    markers[vehicle.id].setLatLng(position);
            // Update popup content
            if (markers[vehicle.id]._popup) {
                markers[vehicle.id]._popup.setContent(createVehiclePopupContent(vehicle));
            }
                } else {
                    const icon = L.divIcon({
                        html: `<i class="fas fa-${vehicle.vehicle_type === 'bus' ? 'bus' : 'van-shuttle'}" 
                              style="color: ${vehicle.status === 'delayed' ? 'var(--error-color)' : 'var(--success-color)'};
                              font-size: 24px;"></i>`,
                        className: 'vehicle-marker',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });
                    
                    markers[vehicle.id] = L.marker(position, {icon: icon})
                        .addTo(map)
                .bindPopup(createVehiclePopupContent(vehicle));
        }
    });
    
    // Remove markers for vehicles no longer active
    Object.keys(markers).forEach(id => {
        if (!vehicles.find(v => v.id === parseInt(id))) {
            map.removeLayer(markers[id]);
            delete markers[id];
            
            // Also remove any route polylines for that vehicle
            if (routePolylines[id]) {
                map.removeLayer(routePolylines[id]);
                delete routePolylines[id];
            }
        }
    });
}

// Helper function to create vehicle popup content
function createVehiclePopupContent(vehicle) {
    // Get a displayed name for the vehicle
    const vehicleName = vehicle.registration_number || vehicle.vehicle_number || `Vehicle #${vehicle.id}`;
    
    return `
        <div style="min-width: 200px;">
            <strong>${vehicleName}</strong><br>
            <div style="margin-top: 8px;">
                <strong>Route:</strong> ${vehicle.route || 'Not set'}<br>
                <strong>Status:</strong> ${vehicle.status}<br>
                ${vehicle.last_updated ? `<strong>Last updated:</strong> ${new Date(vehicle.last_updated).toLocaleString()}<br>` : ''}
            </div>
            ${vehicle.route ? `
                <button class="btn btn-primary view-route-btn" 
                        style="margin-top: 8px; width: 100%; padding: 6px;"
                        onclick="showVehicleRoute(${vehicle.id})">
                    <i class="fas fa-route"></i> View Route
                </button>
            ` : ''}
        </div>
    `;
}

function updateList(vehicles) {
    const vehicleList = document.getElementById('vehicleList');
    
    if (vehicles.length === 0) {
        return;  // Already handled in updateMap
    }
    
    // Clear existing list (already done in updateMap)
    // vehicleList.innerHTML = '';
    
    vehicles.forEach(vehicle => {
        // Use either latitude/longitude or current_latitude/current_longitude
        const lat = vehicle.latitude || vehicle.current_latitude;
        const lng = vehicle.longitude || vehicle.current_longitude;
        
        // Skip vehicles with invalid coordinates
        if (!lat || !lng) {
            return;
        }
        
        // Get a displayed name for the vehicle
        const vehicleName = vehicle.registration_number || vehicle.vehicle_number || `Vehicle #${vehicle.id}`;
                
                // Add to list
                const item = document.createElement('div');
                item.className = 'vehicle-item';
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div>
                    <strong>${vehicleName}</strong>
                            <div style="font-size: 0.875rem; color: var(--secondary-color);">
                        <i class="fas fa-route"></i> ${vehicle.route || 'No route set'}
                            </div>
                        </div>
                        <span class="vehicle-status status-${vehicle.status}">
                            ${vehicle.status}
                        </span>
                    </div>
                `;
                
                item.addEventListener('click', () => {
            const position = [lat, lng];
                    map.setView(position, 15);
                    markers[vehicle.id].openPopup();
            if (vehicle.route) {
                showVehicleRoute(vehicle.id);
            }
                });
                
                vehicleList.appendChild(item);
            });
}

// Function to highlight a vehicle on the map when a notification is received
function highlightVehicle(vehicleId) {
    const marker = markers[vehicleId];
    if (marker) {
        // Get current zoom level
        const currentZoom = map.getZoom();
        // Use the higher zoom level between current and 15
        const zoomLevel = currentZoom > 15 ? currentZoom : 15;
        
        // Highlight the vehicle by panning to it and preserving zoom if zoomed in closer
        map.setView(marker.getLatLng(), zoomLevel);
        marker.openPopup();
        
        // Add a highlight effect
        const icon = marker._icon;
        if (icon) {
            icon.classList.add('highlight-marker');
            setTimeout(() => {
                icon.classList.remove('highlight-marker');
            }, 3000);
        }
    }
}

// Initialize map and start updates
document.addEventListener('DOMContentLoaded', () => {
    console.log("Dashboard loading...");
    
    // Debug socket.io connection
    if (window.socket) {
        console.log("Socket.io connection available");
        window.socket.on('connect', () => {
            console.log('Socket.io connected successfully');
        });
        
        window.socket.on('disconnect', () => {
            console.log('Socket.io disconnected');
        });
        
        window.socket.on('notification', (data) => {
            console.log('Received notification via socket:', data);
        });
        
        window.socket.on('vehicle_approaching', (data) => {
            console.log('Vehicle approaching notification:', data);
        });
        
        window.socket.on('vehicle_update', (data) => {
            console.log('Vehicle update received:', data);
            // Refresh the vehicle data when we get an update
            fetchVehicles();
        });
    } else {
        console.warn("Socket.io not available - notifications won't work in real-time");
    }
    
    initMap();
    fetchVehicles();
    // Update every 5 seconds
    setInterval(fetchVehicles, 5000);
    
    // Add CSS for marker highlighting
    addMarkerHighlightStyle();
    
    // Floating button
    document.getElementById('floatingCenterMap').addEventListener('click', () => {
        if (userLocation) {
            map.setView(userLocation, 15);
        } else {
            alert('Your location is not available yet');
            }
        });
    
    // Start tracking user location
    startLocationTracking();
});

// Add auto-follow button to the map
function addAutoFollowButton() {
    const autoFollowBtn = document.createElement('button');
    autoFollowBtn.id = 'autoFollowBtn';
    autoFollowBtn.className = 'floating-center-btn';
    autoFollowBtn.style.bottom = '90px'; // Position above the center button
    autoFollowBtn.innerHTML = '<i class="fas fa-location-arrow"></i>';
    autoFollowBtn.title = 'Auto-follow my location';
    
    // Add to map container
    document.querySelector('.map-container').appendChild(autoFollowBtn);
    
    // Add event listener
    autoFollowBtn.addEventListener('click', toggleAutoFollow);
    
    // Add styles for the auto-follow button
    const style = document.createElement('style');
    style.textContent = `
        #autoFollowBtn {
            background-color: var(--secondary-color);
            display: flex !important; /* Override any media query hiding */
        }
        #autoFollowBtn.active {
            background-color: var(--success-color);
        }
        #autoFollowBtn:hover {
            background-color: var(--primary-color);
        }
    `;
    document.head.appendChild(style);
}

// Toggle auto-follow mode
function toggleAutoFollow() {
    autoFollowEnabled = !autoFollowEnabled;
    const btn = document.getElementById('autoFollowBtn');
    
    if (autoFollowEnabled) {
        btn.classList.add('active');
        // Immediately center on user
        centerOnUserLocation();
    } else {
        btn.classList.remove('active');
    }
}

// Center map button
document.getElementById('centerMap').addEventListener('click', () => {
    centerOnUserLocation();
});

// Floating center map button (for mobile)
document.getElementById('floatingCenterMap').addEventListener('click', () => {
    centerOnUserLocation();
});

// Function to center on user location
function centerOnUserLocation() {
    if (userLocation && isValidCoordinate(userLocation[0], userLocation[1])) {
        map.setView(userLocation, 15);
        if (userMarker) {
            userMarker.openPopup();
        }
    } else {
        alert('Unable to determine your location. Please enable location services and refresh the page.');
    }
}

// Continuous location tracking for commuters
function startContinuousLocationTracking() {
    if (navigator.geolocation) {
        // Show tracking indicator
        const statusElement = document.getElementById('tracking-status');
        if (statusElement) {
            statusElement.textContent = 'Tracking active';
            statusElement.classList.add('active');
        }
        
        // Set a timeout to handle cases where geolocation takes too long
        const locationTimeout = setTimeout(() => {
            console.log('Location request timed out. Trying again with lower accuracy...');
            if (statusElement) {
                statusElement.textContent = 'Tracking with lower accuracy';
                statusElement.classList.add('warning');
            }
            
            // Try again with lower accuracy settings
            if (watchPositionId !== null) {
                navigator.geolocation.clearWatch(watchPositionId);
            }
            
            watchPositionId = navigator.geolocation.watchPosition(
                handlePositionSuccess,
                handlePositionError,
                { 
                    enableHighAccuracy: false, 
                    timeout: 15000, 
                    maximumAge: 30000 
                }
            );
        }, 10000);
        
        // Start watching position with high accuracy
        watchPositionId = navigator.geolocation.watchPosition(
            handlePositionSuccess,
            handlePositionError,
            {
                enableHighAccuracy: true,
                maximumAge: 5000,
                timeout: 10000
            }
        );
        
        // Function to handle successful position acquisition
        function handlePositionSuccess(position) {
            clearTimeout(locationTimeout);
            
            const currentPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy
            };
            
            // Update status with accuracy information
            if (statusElement && currentPosition.accuracy) {
                let accuracyClass = 'active';
                let accuracyText = 'Tracking active';
                
                if (currentPosition.accuracy > 100) {
                    accuracyClass = 'error';
                    accuracyText = 'Low accuracy';
                } else if (currentPosition.accuracy > 30) {
                    accuracyClass = 'warning';
                    accuracyText = 'Medium accuracy';
                }
                
                statusElement.textContent = accuracyText;
                statusElement.className = 'tracking-status ' + accuracyClass;
            }
            
            // Only send updates if position changed significantly or enough time passed
            if (!lastReportedPosition || 
                calculateDistance(lastReportedPosition, currentPosition) > MIN_DISTANCE_CHANGE ||
                (lastReportedPosition.timestamp && (Date.now() - lastReportedPosition.timestamp) > MIN_TIME_INTERVAL)) {
                
                // Update the timestamp
                currentPosition.timestamp = Date.now();
                
                // Send the location update to server
                if (window.socket) {
                    window.socket.emit('commuter_location', {
                        latitude: currentPosition.lat,
                        longitude: currentPosition.lng,
                        accuracy: currentPosition.accuracy
                    });
                }
                
                // Update user marker on map
                if (userMarker) {
                    userMarker.setLatLng([currentPosition.lat, currentPosition.lng]);
                } else {
                    // Create user marker if it doesn't exist
                    userMarker = L.marker([currentPosition.lat, currentPosition.lng], {
                        icon: L.divIcon({
                            className: 'user-marker',
                            html: '<div class="user-dot"></div>',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        })
                    }).addTo(map);
                }
                
                // Save as last reported position
                lastReportedPosition = currentPosition;
                
                // Update the global userLocation variable for other functions
                userLocation = [currentPosition.lat, currentPosition.lng];
                
                // Auto-follow if enabled
                if (autoFollowEnabled) {
                    map.setView(userLocation, map.getZoom());
                }
            }
        }
        
        // Function to handle position errors
        function handlePositionError(error) {
            clearTimeout(locationTimeout);
            
            console.error('Error getting location:', error);
            const statusElement = document.getElementById('tracking-status');
            if (statusElement) {
                statusElement.textContent = 'Tracking error';
                statusElement.classList.add('error');
            }
        }
    }
}

function stopContinuousLocationTracking() {
    if (watchPositionId !== null) {
        navigator.geolocation.clearWatch(watchPositionId);
        watchPositionId = null;
        
        const statusElement = document.getElementById('tracking-status');
        if (statusElement) {
            statusElement.textContent = 'Tracking stopped';
            statusElement.classList.remove('active');
        }
    }
}

function calculateDistance(pos1, pos2) {
    // Simple Haversine formula to calculate distance between two points
    const R = 6371e3; // Earth radius in meters
    const φ1 = pos1.lat * Math.PI/180;
    const φ2 = pos2.lat * Math.PI/180;
    const Δφ = (pos2.lat - pos1.lat) * Math.PI/180;
    const Δλ = (pos2.lng - pos1.lng) * Math.PI/180;

    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c; // Distance in meters
}

// Add tracking controls to the UI
function addTrackingControls() {
    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'tracking-controls';
    controlsDiv.innerHTML = `
        <div class="card mb-3" style="margin-bottom: 16px;">
            <div class="card-header" style="background-color: var(--primary-color); color: white; padding: 10px 16px; border-radius: 8px 8px 0 0;">
                <h5 style="margin: 0; font-size: 1rem; display: flex; align-items: center; gap: 8px;">
                    <i class="fas fa-satellite-dish"></i> Location Tracking
                </h5>
            </div>
            <div class="card-body" style="padding: 12px 16px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; flex-wrap: wrap; gap: 8px;">
                    <span id="tracking-status" style="font-size: 0.9rem;">Tracking inactive</span>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="tracking-toggle" style="margin: 0; width: 16px; height: 16px;">
                        <label for="tracking-toggle" style="margin: 0; font-size: 0.9rem;">Enable tracking</label>
                    </div>
                </div>
                <small style="color: var(--text-secondary); font-size: 0.8rem; display: block; margin-top: 8px;">
                    When active, your location will be continuously updated to receive notifications about nearby vehicles.
                </small>
            </div>
        </div>
    `;
    
    // Insert before the map container
    const mapContainer = document.querySelector('.map-container');
    mapContainer.parentNode.insertBefore(controlsDiv, mapContainer);
    
    // Add event listener to the toggle
    document.getElementById('tracking-toggle').addEventListener('change', function(e) {
        if (e.target.checked) {
            startContinuousLocationTracking();
        } else {
            stopContinuousLocationTracking();
        }
    });
}

// Add CSS for user marker
function addUserMarkerStyles() {
    const style = document.createElement('style');
    style.textContent = `
        .user-dot {
            width: 20px;
            height: 20px;
            background-color: #2196F3;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        #tracking-status {
            padding: 4px 8px;
            border-radius: 4px;
            background-color: var(--hover-color);
            display: inline-block;
        }
        
        #tracking-status.active {
            color: white;
            background-color: var(--success-color);
            font-weight: bold;
        }
        
        #tracking-status.warning {
            color: white;
            background-color: var(--warning-color);
            font-weight: bold;
        }
        
        #tracking-status.error {
            color: white;
            background-color: var(--error-color);
            font-weight: bold;
        }
        
        @media (max-width: 480px) {
            .tracking-controls .card-body {
                padding: 10px !important;
            }
            
            #tracking-status {
                font-size: 0.8rem !important;
                padding: 3px 6px;
            }
        }
    `;
    document.head.appendChild(style);
}

// Function to show vehicle routes
function showVehicleRoute(vehicleId) {
    // Show loading state
    console.log(`Loading route for vehicle ${vehicleId}...`);
    
    // Fetch the latest vehicle data
            fetch(`/api/vehicles/${vehicleId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`API error: ${response.status} ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            console.log("Vehicle data received:", data);
            
            if (data.success && data.vehicle) {
                // Check if vehicle has route information
                const vehicle = data.vehicle;
                
                if (vehicle.route) {
                    // Draw the route on the map
                    drawVehicleRoute(vehicleId, vehicle.route);
                    
                    // If there's a marker for this vehicle, make sure it's visible
                    if (markers[vehicleId]) {
                        // Get coordinates using the same approach as elsewhere
                        const lat = vehicle.latitude || vehicle.current_latitude;
                        const lng = vehicle.longitude || vehicle.current_longitude;
                        const position = markers[vehicleId].getLatLng();
                        
                        // If we have a route polyline, fit the map to the route bounds
                        if (routePolylines[vehicleId]) {
                            map.fitBounds(routePolylines[vehicleId].getBounds(), {
                                padding: [50, 50]
                            });
                        } else {
                            // Otherwise center on the vehicle
                            map.setView(position, 15);
                        }
                    }
                } else {
                    // No route set
                    alert("No route information available for this vehicle.");
                }
            } else {
                alert(`Error: ${data.error || "Could not retrieve vehicle information"}`);
            }
        })
        .catch(error => {
            console.error('Error getting vehicle details:', error);
            alert(`Error retrieving vehicle information: ${error.message}`);
        });
}

// Function to draw route for a vehicle
function drawVehicleRoute(vehicleId, routeName) {
    // Remove existing route if any
    if (routePolylines[vehicleId]) {
        map.removeLayer(routePolylines[vehicleId]);
        delete routePolylines[vehicleId];
    }
    
    // Skip if map not initialized or invalid route
    if (!map || !routeName) return;
    
    console.log(`Drawing route for vehicle ${vehicleId}: ${routeName}`);

    // Define common routes with coordinates
    const routes = {
        "Bataraza to Brooke's Point": [
            [8.6737, 117.6544], // Bataraza coordinates
            [8.7803, 117.6843], // Intermediate point
            [8.7894, 117.7012], // Intermediate point
            [8.7979, 117.8302], // Brooke's Point coordinates
        ],
        "Puerto Princesa to El Nido": [
            [9.7406, 118.7397], // Puerto Princesa
            [10.1152, 119.3138], // Intermediate point
            [10.5512, 119.4917], // Intermediate point
            [11.1923, 119.4120] // El Nido
        ],
        "Taytay to San Vicente": [
            [10.8285, 119.5270], // Taytay 
            [10.6885, 119.3752], // Intermediate point
            [10.5207, 119.2964] // San Vicente
        ],
        // Add more predefined routes as needed
    };
    
    // Get coordinates for the specified route
    let coordinates = routes[routeName];
    
    // If not a predefined route, try to parse it as "A to B" format
    if (!coordinates) {
        const routeParts = routeName.split(' to ');
        if (routeParts.length === 2) {
            // Try to get the vehicle position for the start point if available
            const vehicle = markers[vehicleId];
            let origin, destination;
            
            // Function to fetch route from OSRM
            const fetchRouteFromOSRM = (startPoint, endPoint) => {
                const osrmApiUrl = `https://router.project-osrm.org/route/v1/driving/${startPoint.lng},${startPoint.lat};${endPoint.lng},${endPoint.lat}?overview=full&geometries=geojson`;
                
                fetch(osrmApiUrl)
                    .then(response => response.json())
                    .then(data => {
                        if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                            // Get the coordinates from the response
                            const routeCoordinates = data.routes[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                            
                            // Draw the route with these coordinates
                            updateRoutePolyline(vehicleId, routeCoordinates);
                        } else {
                            console.error('Failed to get route from OSRM:', data);
                            // Fall back to a straight line if needed
                            if (startPoint && endPoint) {
                                const fallbackCoords = [
                                    [startPoint.lat, startPoint.lng],
                                    [endPoint.lat, endPoint.lng]
                                ];
                                updateRoutePolyline(vehicleId, fallbackCoords);
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching route from OSRM:', error);
                        // Fall back to a straight line
                        if (startPoint && endPoint) {
                            const fallbackCoords = [
                                [startPoint.lat, startPoint.lng],
                                [endPoint.lat, endPoint.lng]
                            ];
                            updateRoutePolyline(vehicleId, fallbackCoords);
                        }
                    });
            };
            
            if (vehicle) {
                // If the vehicle has a current position, use it as the starting point
                const vehiclePos = vehicle.getLatLng();
                origin = { lat: vehiclePos.lat, lng: vehiclePos.lng };
                
                // Get the destination coordinates through geocoding
                fetchGeocode(routeParts[1])
                    .then(destCoords => {
                        if (destCoords) {
                            // Once we have both origin and destination, fetch the route
                            fetchRouteFromOSRM(origin, destCoords);
                        }
                    })
                    .catch(err => {
                        console.error("Error geocoding destination:", err);
                    });
            } else {
                // Try to get coordinates for both origin and destination through geocoding
                Promise.all([
                    fetchGeocode(routeParts[0]),
                    fetchGeocode(routeParts[1])
                ]).then(results => {
                    if (results[0] && results[1]) {
                        const [originCoords, destCoords] = results;
                        // Once we have both coordinates, fetch the route
                        fetchRouteFromOSRM(originCoords, destCoords);
                    }
                }).catch(err => {
                    console.error("Error geocoding route points:", err);
                });
            }
            
            // Return early since we're handling the route asynchronously
            return;
        }
    }
    
    // Draw the route if coordinates exist (for predefined routes)
    if (coordinates && coordinates.length > 1) {
        updateRoutePolyline(vehicleId, coordinates);
    }
}

// Helper function to update route polyline with coordinates
function updateRoutePolyline(vehicleId, coordinates) {
    if (!map) return;
    
    if (routePolylines[vehicleId]) {
        routePolylines[vehicleId].setLatLngs(coordinates);
    } else {
        routePolylines[vehicleId] = L.polyline(coordinates, {
            color: '#2196F3',
            weight: 5,
            opacity: 0.8
        }).addTo(map);
    }
}

// Helper function to get coordinates from a place name
async function fetchGeocode(placeName) {
    try {
        const response = await fetch(`/api/geocode/search?q=${encodeURIComponent(placeName)}&limit=1`);
        const data = await response.json();
        
        if (data && data.length > 0) {
            return {
                lat: parseFloat(data[0].lat),
                lng: parseFloat(data[0].lon)
            };
        }
        return null;
    } catch (error) {
        console.error('Error geocoding:', error);
        return null;
    }
}

// Add CSS and event listeners for marker highlighting
function addMarkerHighlightStyle() {
    const style = document.createElement('style');
    style.textContent = `
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        .highlight-marker {
            animation: pulse 1s ease-in-out 3;
        }
        
        /* Hide the center map button in the header on mobile */
        @media (max-width: 768px) {
            .page-header .btn-center-map {
                display: none;
            }
        }
    `;
    document.head.appendChild(style);
    
    // Listen for notification events from the base template
    document.addEventListener('vehicleApproachingNotification', function(e) {
        const vehicleId = e.detail.vehicleId;
        highlightVehicle(vehicleId);
    });
    
    // Listen for direct socket events
    if (window.socket) {
        window.socket.on('vehicle_approaching', function(data) {
            console.log('Received vehicle_approaching event:', data);
            highlightVehicle(data.vehicle_id);
            
            // Show a toast notification
            if (typeof showToast === 'function') {
                showToast(
                    `${data.vehicle_type.charAt(0).toUpperCase() + data.vehicle_type.slice(1)} Approaching`, 
                    `${data.vehicle_number} is ${data.distance}m away. ETA: ~${data.eta} minutes`,
                    'success'
                );
            }
        });
    }
    
    // Add tracking controls and styles
    addTrackingControls();
    addUserMarkerStyles();
    
    // Add auto-follow button
    addAutoFollowButton();
}
</script>
{% endblock %} 